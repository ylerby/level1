#### 1.Какой самый эффективный способ конкатенации строк?

Самым эффективным способом конкатенации 
строк является использование strings.Builder

```go
func concatenation(x, y string) string {
    var builder strings.Builder // инициализация builder`a
	
    builder.Grow(len(x) + len(y)) // выделение памяти
	
    builder.WriteString(x) // добавляем строки
    builder.WriteString(y)
    return builder.String()
}
```

#### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейс - определяет и описывает методы, которые
должны быть у конкретного типа.

```go
// Device - структура с произвольными методами
type Device interface {
    PlayMusic()
    LaunchBrowser()
}

// Computer - структура с произвольными полями
type Computer struct {
    cpuModel string
}

// Phone - структура с произвольными полями
type Phone struct {
    brand string
}

// имплементируем методы PlayMusic и LaunchBrowser
// в структурах Computer и Phone

func (c Computer) PlayMusic() {
    fmt.Println("включена музыка на компьютере")
}

func (c Computer) LaunchBrowser() {
    fmt.Println("запущен браузер на компьютере")
}

func (p Phone) PlayMusic() {
    fmt.Println("включена музыка на телефоне")
}

func (p Phone) LaunchBrowser() {
    fmt.Println("запущен браузер на телефоне")
}

func main() {
    newComputer := Computer{}
    newPhone := Phone{}
    
    // в анонимной функции вызываем имплементируемые методы от объектов типа Device
    // но так как структуры Computer и Phone и имплементируют эти методы, то
    // в качестве параметров можно передать их
    func(computer, phone Device) {
        computer.PlayMusic()
        computer.LaunchBrowser()
        phone.PlayMusic()
        phone.LaunchBrowser()
    }(newComputer, newPhone)
}
```

#### 3. Чем отличаются RWMutex от Mutex?

Mutex из пакета sync предоставляет блокировку для части кода, позволяя только одному потоку выполнения за раз получать доступ к общим данным. Это означает, что при использовании Mutex только один поток может захватить блокировку в любой момент времени.

RWMutex позволяет нескольким потокам выполнения получать доступ к общим данным для чтения одновременно, но только один поток может получить блокировку для записи. 

#### 4. Чем отличаются буферизированные и не буферизированные каналы?

Во-первых, отличается процесс инициализации каналов:
```go
ch1 := make(chan int) // ининициализация небуферизированного канала типа int
ch2 := make(chan int, 5) // ининициализация буферизированного канала типа int, с буфером размерностью 5
```

Во-вторых, небуферизированные каналы блокируют отправителя до тех пор, пока получатель не прочитает данные,
а в случае с буферизированным каналом, отправитель будет заблокирован только тогда, когда буфер заполнен, а получатель — когда буфер пуст

#### 5. Какой размер у структуры struct{}{}?
0 байт

Убедиться в этом можно с помощью функции Sizeof из пакета unsafe
```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println(unsafe.Sizeof(struct{}{}))
}
```

#### 6. Есть ли в Go перегрузка методов или операторов?
В Golang нет перегрузки методов и операторов. То есть нельзя определять несколько методов или операторов с тем же именем

#### 7. В какой последовательности будут выведены элементы map[int]int?
Пример:
```go
m[0]=1 
m[1]=124 
m[2]=281
```
Порядок вывода элементов map при каждом запуске программы будет случайным

#### 8. В чем разница make и new?

```go
var := new(T)
``` 
создает неименованную переменную типа Т, инициализирует ее нулевым значением типа Т и возвращает ее адрес (*T)


```go
var := make(T, args)
```
создает и возвращает инициализированное значение типа T. 
Применимо для типов slice, map, chan

#### 9. Сколько существует способов задать переменную типа slice или map?

Способы создания slice:
```go
1. arr := []int{1, 2, 3}
2. arr1 := make([]int, 10)
3. arr3 := make([]int, 10, 12)
4. var arr4 []int
```

Способы создания map: 
```go
1. map1 := map[int]int{}
2. map2 := make(map[int]int)
3. map3 := make(map[int]int, 10)
4. var map4 = map[int]int{}
```

#### 10. Что выведет данная программа и почему?
```go 
func update(p *int) {
    b := 2
    p = &b
}

func main() { 
    var (
        a=1
        p = &a 
    )
    fmt.Println(*p) 
    update(p) 
    fmt.Println(*p)
}
```

Выводом будет:
```go
1
1
```

Значение не изменилось, так как в функции update 
мы изменяем саму переменную, а не ее адрес

#### 11. Что выведет данная программа и почему?
```go 
func main() {
    wg := sync.WaitGroup{} 
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done() 
        }(wg, i)
    }
    wg.Wait() 
    fmt.Println("exit")
}
```

Выводом будет: 
```go
// порядок вывода чисел будет случайным
4
3
1
2
0
fatal error: all goroutines are asleep - deadlock!
```

Ошибка возникает из-за того, что wg передается в анонимную функцию по значению, что приводит к "вечному" 
ожиданию выполнению горутин (wg.Wait())

#### 12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
        n := 1
        n++ 
    }
    fmt.Println(n) 
}
```

Выводом будет: 
```go
1 
```

Выводится 1, а не 2, потому что внутри 
```go
if {
	
}
```

переменная n инициализируется заново


#### 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}
    
func main() {
    var a = []int8{1, 2, 3, 4, 5} 
    someAction(a, 6) 
    fmt.Println(a)
}
```

Выводом будет:
```go
[100 2 3 4 5]
```

Значение 100 будет добавлено в слайс с v[0] и это изменение
будет отображаться и в функции main, так как слайс передан по ссылке.
Однако значение b int8 не будет отображено, так как при использовании append(v, b) будет 
создана копия слайса и значение будет добавляться уже в копию


#### 14. Что выведет данная программа и почему?
```go 
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a") 
        slice[0] = "b"
        slice[1] = "b" 
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice) 
}
```

Выводом будет:

```
[b b a][a a]
```

Это объясняется тем, что в анонимной функции сначала создается копия
слайса, а затем в уже созданной копии изменяются значения. 
Поэтому изменения внутри анонимной функции не будут отображены при выводе в main